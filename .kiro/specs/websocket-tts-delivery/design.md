# Design Document

## Overview

This design implements a WebSocket-based real-time audio delivery system that bridges Kafka-produced commentary events with browser-based audio playback. The system consists of three main components:

1. **WebSocket Server** (FastAPI backend) - Manages WebSocket connections and streams audio events from Kafka
2. **Audio File Server** (FastAPI static files) - Serves MP3 files generated by ElevenLabs
3. **WebSocket Client** (React frontend) - Manages connection, queues audio, and handles playback

The architecture maintains the existing Kafka-based event flow while adding a WebSocket layer for browser delivery.

## Architecture

### System Flow

```
[consumer_commentary.py] 
    â†“ (generates TTS, saves MP3)
    â†“ (produces to Kafka)
[commentary_audio topic]
    â†“ (consumed by)
[WebSocket Manager Service]
    â†“ (streams via WebSocket)
[React Frontend]
    â†“ (fetches audio file)
[FastAPI Static File Server]
    â†“ (plays audio)
[Browser Audio Player]
```

### Component Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Backend (FastAPI)                     â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  WebSocket       â”‚      â”‚  Kafka Consumer Thread  â”‚ â”‚
â”‚  â”‚  Manager         â”‚â—„â”€â”€â”€â”€â”€â”¤  (commentary_audio)     â”‚ â”‚
â”‚  â”‚  /ws/{game_id}   â”‚      â”‚                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚           â”‚                                              â”‚
â”‚           â”‚ WebSocket                                    â”‚
â”‚           â”‚                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚  â”‚  Static Files    â”‚                                   â”‚
â”‚  â”‚  /audio/*.mp3    â”‚                                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ HTTP/WebSocket
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Frontend (React)                         â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  WebSocket       â”‚      â”‚  Audio Queue Manager    â”‚ â”‚
â”‚  â”‚  Client Hook     â”‚â”€â”€â”€â”€â”€â–ºâ”‚  - Queue management     â”‚ â”‚
â”‚  â”‚  useCommentary   â”‚      â”‚  - Sequential playback  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  UI Components                                    â”‚   â”‚
â”‚  â”‚  - Connection status                              â”‚   â”‚
â”‚  â”‚  - Current commentary display                     â”‚   â”‚
â”‚  â”‚  - Audio player controls                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Components and Interfaces

### 1. WebSocket Manager (Backend)

**File:** `backend/websocket_manager.py`

**Responsibilities:**
- Manage active WebSocket connections
- Consume from `commentary_audio` Kafka topic
- Route audio events to appropriate WebSocket clients
- Handle connection lifecycle (connect, disconnect, errors)

**Key Classes:**

```python
class ConnectionManager:
    """Manages active WebSocket connections"""
    
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, game_id: str):
        """Accept and register a new WebSocket connection"""
        
    async def disconnect(self, websocket: WebSocket, game_id: str):
        """Remove a WebSocket connection"""
        
    async def send_audio_event(self, game_id: str, message: dict):
        """Send audio event to all clients watching a game"""
        
    async def broadcast(self, message: dict):
        """Send message to all connected clients"""
```

```python
class KafkaWebSocketBridge:
    """Consumes Kafka messages and sends to WebSocket clients"""
    
    def __init__(self, connection_manager: ConnectionManager):
        self.connection_manager = connection_manager
        self.consumer = None
        
    async def start_consuming(self):
        """Start consuming from commentary_audio topic in background"""
        
    async def process_audio_event(self, event: dict):
        """Process and route audio event to appropriate clients"""
```

**WebSocket Endpoint:**

```python
@app.websocket("/ws/commentary/{game_id}")
async def websocket_endpoint(websocket: WebSocket, game_id: str):
    """
    WebSocket endpoint for receiving live commentary
    
    Path params:
        game_id: The lichess game ID to subscribe to
        
    Message format (server -> client):
    {
        "event": "commentary_audio",
        "game_id": "abc123",
        "move_number": 5,
        "latest_move": "e4",
        "commentary_text": "A bold opening move...",
        "audio_url": "/audio/Sat_Dec_27_002210_2025.mp3",
        "created_at_ms": 1703721730000
    }
    """
```

### 2. Static File Server (Backend)

**Integration:** Add to existing `backend/main.py`

```python
from fastapi.staticfiles import StaticFiles

# Mount static files directory
app.mount("/audio", StaticFiles(directory="audio"), name="audio")
```

**Configuration:**
- Serves files from `audio/` directory
- CORS already configured in main.py
- Returns 404 for missing files automatically

### 3. WebSocket Client Hook (Frontend)

**File:** `frontend/src/hooks/useCommentary.js`

**Responsibilities:**
- Establish and maintain WebSocket connection
- Handle reconnection logic
- Manage audio playback queue
- Provide connection status and current commentary state

**Interface:**

```javascript
/**
 * Custom hook for managing live commentary WebSocket connection
 * 
 * @param {string} gameId - The lichess game ID to subscribe to
 * @returns {Object} Commentary state and controls
 */
function useCommentary(gameId) {
    return {
        // Connection state
        isConnected: boolean,
        connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error',
        
        // Commentary state
        currentCommentary: {
            text: string,
            moveNumber: number,
            latestMove: string,
            isPlaying: boolean
        } | null,
        
        // Queue state
        queueLength: number,
        
        // Error state
        error: string | null,
        
        // Controls
        connect: () => void,
        disconnect: () => void,
        clearQueue: () => void
    };
}
```

### 4. Audio Queue Manager (Frontend)

**File:** `frontend/src/utils/audioQueue.js`

**Responsibilities:**
- Queue incoming audio events
- Play audio files sequentially
- Handle audio loading and playback errors
- Provide playback state

**Key Class:**

```javascript
class AudioQueueManager {
    constructor() {
        this.queue = [];
        this.isPlaying = false;
        this.currentAudio = null;
        this.onStateChange = null; // Callback for state updates
    }
    
    /**
     * Add audio event to queue and start playback if idle
     */
    enqueue(audioEvent) {
        this.queue.push(audioEvent);
        if (!this.isPlaying) {
            this.playNext();
        }
    }
    
    /**
     * Play next audio in queue
     */
    async playNext() {
        if (this.queue.length === 0) {
            this.isPlaying = false;
            this.notifyStateChange();
            return;
        }
        
        const event = this.queue.shift();
        this.isPlaying = true;
        
        try {
            await this.playAudio(event);
        } catch (error) {
            console.error('Audio playback failed:', error);
        }
        
        // Play next after current finishes
        this.playNext();
    }
    
    /**
     * Play a single audio file
     */
    async playAudio(event) {
        return new Promise((resolve, reject) => {
            const audio = new Audio(`http://127.0.0.1:8000${event.audio_url}`);
            this.currentAudio = audio;
            
            audio.onended = () => resolve();
            audio.onerror = () => reject(new Error('Audio load failed'));
            
            audio.play().catch(reject);
            this.notifyStateChange(event);
        });
    }
    
    /**
     * Clear all queued audio
     */
    clear() {
        this.queue = [];
        if (this.currentAudio) {
            this.currentAudio.pause();
            this.currentAudio = null;
        }
        this.isPlaying = false;
        this.notifyStateChange();
    }
    
    notifyStateChange(currentEvent = null) {
        if (this.onStateChange) {
            this.onStateChange({
                isPlaying: this.isPlaying,
                queueLength: this.queue.length,
                currentEvent
            });
        }
    }
}
```

### 5. UI Components (Frontend)

**File:** `frontend/src/components/CommentaryPlayer.jsx`

**Component Structure:**

```jsx
function CommentaryPlayer({ gameId }) {
    const {
        isConnected,
        connectionStatus,
        currentCommentary,
        queueLength,
        error
    } = useCommentary(gameId);
    
    return (
        <div className="commentary-player">
            {/* Connection Status Indicator */}
            <ConnectionStatus status={connectionStatus} />
            
            {/* Current Commentary Display */}
            {currentCommentary && (
                <div className="current-commentary">
                    <div className="move-info">
                        Move {currentCommentary.moveNumber}: {currentCommentary.latestMove}
                    </div>
                    <div className="commentary-text">
                        {currentCommentary.text}
                    </div>
                    {currentCommentary.isPlaying && (
                        <div className="playing-indicator">ðŸ”Š Playing...</div>
                    )}
                </div>
            )}
            
            {/* Queue Status */}
            {queueLength > 0 && (
                <div className="queue-status">
                    {queueLength} commentary in queue
                </div>
            )}
            
            {/* Error Display */}
            {error && (
                <div className="error-message">
                    {error}
                </div>
            )}
        </div>
    );
}
```

## Data Models

### Audio Event Message (WebSocket)

```typescript
interface AudioEvent {
    event: "commentary_audio";
    game_id: string;
    move_number: number;
    latest_move: string;
    commentary_text: string;
    audio_url: string;  // e.g., "/audio/Sat_Dec_27_002210_2025.mp3"
    created_at_ms: number;
}
```

### WebSocket Connection State

```typescript
interface ConnectionState {
    status: 'connecting' | 'connected' | 'disconnected' | 'error';
    gameId: string | null;
    reconnectAttempts: number;
    lastError: string | null;
}
```

### Audio Queue Item

```typescript
interface QueuedAudio {
    event: AudioEvent;
    addedAt: number;
    retryCount: number;
}
```

## Error Handling

### Backend Error Scenarios

1. **Kafka Consumer Error**
   - Log error with context
   - Continue consuming (don't crash)
   - Emit error event to monitoring if available

2. **WebSocket Send Failure**
   - Log failed send attempt
   - Remove dead connections from manager
   - Continue processing other connections

3. **Invalid Audio Event**
   - Log validation error
   - Skip malformed event
   - Continue processing

### Frontend Error Scenarios

1. **WebSocket Connection Failure**
   - Display "Disconnected" status
   - Attempt reconnection with exponential backoff (1s, 2s, 4s, 8s, max 30s)
   - Show user-friendly error message

2. **Audio File Load Failure**
   - Log error to console
   - Skip to next audio in queue
   - Display brief error notification (non-blocking)

3. **Audio Playback Failure**
   - Catch playback promise rejection
   - Skip to next audio
   - Log error for debugging

## Testing Strategy

### Backend Testing

1. **Unit Tests**
   - ConnectionManager: add/remove connections, send messages
   - KafkaWebSocketBridge: message routing logic
   - WebSocket endpoint: connection handling

2. **Integration Tests**
   - End-to-end: Kafka message â†’ WebSocket delivery
   - Static file serving with CORS
   - Multiple concurrent WebSocket connections

3. **Manual Testing**
   - Connect multiple clients to same game_id
   - Disconnect/reconnect scenarios
   - Kafka consumer lag handling

### Frontend Testing

1. **Unit Tests**
   - AudioQueueManager: queue operations, playback sequencing
   - useCommentary hook: state management, reconnection logic

2. **Integration Tests**
   - WebSocket connection lifecycle
   - Audio playback with real MP3 files
   - Queue management with multiple rapid events

3. **Manual Testing**
   - Network disconnection/reconnection
   - Audio playback on different browsers
   - UI responsiveness during playback

## Performance Considerations

### Backend

- **Kafka Consumer**: Run in separate thread/task to avoid blocking WebSocket sends
- **Connection Limit**: Monitor active WebSocket connections (FastAPI handles this well)
- **Message Batching**: Not needed for this use case (low frequency events)

### Frontend

- **Audio Preloading**: Consider preloading next audio in queue while current plays
- **Memory Management**: Clear old Audio objects after playback
- **Queue Limits**: Optionally limit queue size to prevent memory issues (e.g., max 10 items)

## Security Considerations

1. **WebSocket Authentication**: Currently using game_id in path; consider adding token-based auth if needed
2. **CORS**: Already configured in main.py for localhost:5173
3. **Audio File Access**: Files are publicly accessible via URL; consider signed URLs if privacy needed
4. **Rate Limiting**: Consider rate limiting WebSocket connections per IP if abuse is a concern

## Deployment Considerations

1. **Audio File Storage**: Current local filesystem storage works for single-server deployment
2. **Scalability**: For multi-server deployment, consider:
   - Shared audio storage (S3, NFS)
   - Redis pub/sub for WebSocket message distribution
   - Load balancer with sticky sessions
3. **Monitoring**: Add metrics for:
   - Active WebSocket connections
   - Audio event delivery latency
   - Failed audio playback rate

## Dependencies

### Backend (Python)
- `fastapi` - Already installed
- `websockets` - Included with FastAPI
- `confluent-kafka` - Already installed
- `asyncio` - Standard library

### Frontend (JavaScript)
- Native WebSocket API (browser built-in)
- Native Audio API (browser built-in)
- React hooks (already using React 19)

No additional dependencies required!
