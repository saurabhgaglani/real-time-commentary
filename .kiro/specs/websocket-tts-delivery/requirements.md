# Requirements Document

## Introduction

This feature enables real-time delivery of chess commentary audio from the backend to the frontend UI. When the commentary consumer generates TTS audio files via ElevenLabs, the system must stream these audio events to connected clients via WebSocket, allowing users to hear live commentary as moves are played in their chess game.

The system currently generates commentary text, converts it to audio via ElevenLabs, saves MP3 files locally, and publishes audio metadata to a Kafka topic. This feature bridges the gap between Kafka-based audio events and browser-based audio playback.

## Requirements

### Requirement 1: WebSocket Connection Management

**User Story:** As a user watching my chess game, I want to establish a persistent connection to receive live commentary audio, so that I can hear commentary in real-time without polling or refreshing.

#### Acceptance Criteria

1. WHEN a user's game session starts THEN the frontend SHALL establish a WebSocket connection to the backend
2. WHEN the WebSocket connection is established THEN the backend SHALL authenticate the connection using the game_id or username
3. IF the WebSocket connection drops THEN the frontend SHALL attempt to reconnect automatically with exponential backoff
4. WHEN a user closes the browser or navigates away THEN the WebSocket connection SHALL be cleanly closed
5. WHEN multiple users are watching different games THEN each SHALL maintain independent WebSocket connections

### Requirement 2: Audio Event Streaming

**User Story:** As a backend service, I want to consume audio events from Kafka and stream them to connected WebSocket clients, so that commentary reaches users in real-time.

#### Acceptance Criteria

1. WHEN the backend WebSocket service starts THEN it SHALL consume messages from the `commentary_audio` Kafka topic
2. WHEN an audio event is consumed from Kafka THEN the backend SHALL identify which WebSocket client(s) should receive it based on game_id
3. WHEN a matching WebSocket client is connected THEN the backend SHALL send the audio event payload to that client
4. IF no client is connected for a game_id THEN the backend SHALL skip that audio event without error
5. WHEN sending audio events THEN the payload SHALL include: event type, game_id, move_number, latest_move, commentary_text, audio_url, and timestamp

### Requirement 3: Frontend Audio Playback Queue

**User Story:** As a user, I want commentary audio to play sequentially without overlapping, so that I can clearly understand each piece of commentary.

#### Acceptance Criteria

1. WHEN the frontend receives an audio event via WebSocket THEN it SHALL add the audio to a playback queue
2. WHEN the queue is empty and audio is added THEN playback SHALL start immediately
3. WHEN audio is already playing and new audio arrives THEN the new audio SHALL wait in the queue
4. WHEN an audio file finishes playing THEN the next audio in the queue SHALL play automatically
5. IF an audio file fails to load or play THEN the system SHALL skip to the next audio in the queue and log the error

### Requirement 4: Static Audio File Serving

**User Story:** As a frontend application, I want to fetch audio files from the backend via HTTP, so that I can play the MP3 files generated by ElevenLabs.

#### Acceptance Criteria

1. WHEN the backend starts THEN it SHALL serve static files from the `/audio` directory
2. WHEN the frontend receives an audio_url like `/audio/filename.mp3` THEN it SHALL be able to fetch the file via HTTP GET
3. WHEN an audio file is requested THEN the backend SHALL return it with appropriate MIME type `audio/mpeg`
4. IF an audio file does not exist THEN the backend SHALL return a 404 error
5. WHEN serving audio files THEN CORS headers SHALL be configured to allow frontend origin access

### Requirement 5: Error Handling and Resilience

**User Story:** As a system, I want to handle network failures and errors gracefully, so that temporary issues don't break the user experience.

#### Acceptance Criteria

1. WHEN a WebSocket message fails to send THEN the backend SHALL log the error and continue processing other messages
2. WHEN the Kafka consumer encounters an error THEN it SHALL log the error and continue consuming subsequent messages
3. WHEN the frontend fails to play an audio file THEN it SHALL display a non-intrusive error message and continue with the next audio
4. WHEN the WebSocket reconnects after a disconnection THEN the frontend SHALL not replay old audio events
5. IF the backend WebSocket service crashes THEN it SHALL restart and resume consuming from the latest Kafka offset

### Requirement 6: UI Feedback and Status

**User Story:** As a user, I want to see the status of my commentary connection and current playback, so that I know the system is working.

#### Acceptance Criteria

1. WHEN the WebSocket is connected THEN the UI SHALL display a "Connected" status indicator
2. WHEN the WebSocket is disconnected THEN the UI SHALL display a "Disconnected" or "Reconnecting" status
3. WHEN commentary audio is playing THEN the UI SHALL display the current commentary text
4. WHEN audio is queued THEN the UI MAY display the number of pending commentary items
5. WHEN an error occurs THEN the UI SHALL display a user-friendly error message
